<!DOCTYPE html>
<!-- This file is part of PinballY
 Copyright 2018 Michael J Roberts | GPL v3 or later | NO WARRANTY -->
<html>
<head>
   <title>PinballY Help</title>
   <link rel="stylesheet" type="text/css" href="main.css">
</head>
<body>
<div class="navbar">
   <a href="PinballY.html">PinballY Help</a>
</div>

<h1>Javascript Scripting</h1>

<p>
   PinballY includes a full Javascript engine for user scripting customizations.
   This is a new feature in the Beta 2 release, and it's still very preliminary
   and experimental.  Be aware of two big caveats:
</p>
<ul>
   <li>It's not very fleshed out yet
   <li>Many details are likely to change as it matures
</ul>

<p>
   This feature is preliminary and experimental, but the underlying
   Javascript engine is quite robust.  The Javascript system is ChakraCore,
   Microsoft's modern, ES6-compliant engine that they built from the ground up
   for their Edge browser.  Chakra Core has top-tier performance and provides
   strong support for modern Javascript language standards.
</p>

<h2>Is this like Web browser Javascript?</h2>

<p>
   Yes and no.  PinballY's Javascript <i>language</i> works exactly like
   the Javascript in a Web browser, but that doesn't mean it's exactly like
   programming in a Web page.  That's because many of the objects and
   functions you'd use when programming in a Web page are part of the
   browser, not part of Javascript itself.  For example, the "document" and
   "window" objects, and all of the HTML elements, are browser objects.
   PinballY doesn't have those objects because it's not a Web browser.
   Instead, PinballY provides its own, somewhat different set of objects
   that represent the PinballY user interface environment.
</p>
<p>
   That said, we've tried to make things the similar to the familiar
   elements of browser Javascript wherever
   possible.  For features in PinballY that have natural analogs in
   a browser, we've tried to use the same Javascript names and behaviors.
   For example, events are handled in a very similar way, and a number
   of common <a href="#browserLikeFuncs">browser-like functions</a> are
   available, such as timeouts and intervals.
</p>

<h2>Javascript language documentation</h2>

<p>
   This section isn't a Javascript tutorial or reference manual.
   You can find lots of both of those on the Web.  One good place to look is the
   <a target="_blank" href="https://developer.mozilla.org/">Mozilla Developer Network (MDN)</a>,
   which has extensive and up-to-date Javscript documentation:
</p>
<div class="indented">
   <a target="_blank" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript">JavaScript documentation on MDN</a>
</div>
<p>
   The only thing you have to keep in mind while reading Web
   Javascript documentation is that PinballY doesn't have the
   usual browser environment objects ("document", the HTML DOM tree, etc).
   Many Javascript tutorials assume that the only place you'd use
   Javascript is in a Web page, so many take it for granted
   in their examples that browser objects are always present.
</p>

<h2>How to enable scripting</h2>

<p>
   Scripting is automatically enabled.  To use it, create a script file
   called <b>main.js</b>, and put it in the <b>Scripts</b>
   folder within your main PinballY program folder.  At startup, PinballY
   will look to see if this file exists, and if so, PinballY will
   automatically load and run the file.
</p>
<p>
   What goes in this file?  Generally speaking, it can contain any valid
   Javascript code.  More specifically, it will usually consist of a
   set of event handler functions for one or more of the program events that
   PinballY defines, and some startup code that tells PinballY to call
   the handlers when the related program events occur.  That's the
   same basic approach that you'd use in Web page Javascript, but in
   this case you're working with PinballY's event scheme rather than browser
   events.
</p>
<p>
   It's also possible to organize your code into multiple files, and to use
   modules written by other people.  See <a href="#multipleFiles">How to
   use multiple script files</a> below.

<h2>Overall program flow</h2>

<p>
   When PinballY starts up, it loads the <b>main.js</b> file that
   you provide.  Javascript immediately executes all of the code in
   the file that's defined outside of any function or class
   definitions.  
   If you're familiar with more traditional programming languages
   like C or C++, this "outer" code in a Javascript file is the
   equivalent of the "main" routine that's executed at program startup.
</p>
<p>
   The main thing that the top-level code in your main.js file
   will usually do is set up <i>event listeners</i>.  An event
   listener is a function you write that will be called when a
   specific event occurs.  Once the event listener is set up,
   PinballY will call it whenever the associated event occurs.
</p>

<h2>Events</h2>

<p>
   Most of the code you write for PinballY will be there to handle
   events.  An event is something like "the user pressed a key"
   or "a game is being launched".
</p>
<p>
   A function you write to handle an event is called an
   <i>event listener</i>.  PinballY notifies you that
   something is happening by calling your event listeners for
   that particular event.
</p>
<p>
   If you've used Visual Basic or C#, you might expect that
   event handlers are set up by using a special function name
   when you define an event handler function.  That's not how it works
   in Javascript.   Instead, you set up each handler explicitly,
   so you can use any name for any handler function.
</p>
<p>
   You set up an event listener by calling a function to add
   the listener to the <i>event target</i> object that generates
   the events of interest.  An event target represents a PinballY
   user interface element that's associated with one or more
   events.  The primary event target for most events is the
   <b>mainWindow</b> object, which represents the main playfield
   window.  Most UI events are handled in this window, even
   when other windows (such as the backglass or DMD) are open.
</p>
<p>
   To attach an event listener to an event target, you use the
   <b>on()</b> method of the event target object:
</p>

<div class="code">
// This is an event listener function for "key down" events.  The
// name doesn't matter, because we're going to call on() in a moment
// to register the listener.  (This isn't like Visual Basic, where events
// are tied to special function names.)

function myListener(event)
{
   // do something with the key-down event
}

// &gt;&gt;&gt;&gt;&gt; Here's where we register our listener! &lt;&lt;&lt;&lt;&lt; 
mainWindow.on("keydown", myListener);

// Event listeners don't even have to be named at all.  You can use
// anonymous functions, like this:
mainWindow.on("keydown", function(ev) { /* do something with the event */ });

// You can also use the even more succinct "arrow" function notation
mainWindow.on("keydown", (ev) => { /* handler */ });
</div>

<p>
   You can also specify more than one event at a time, by separating
   the event names with spaces:
</p>
<div class="code">
mainWindow.on("keydown keyup", (ev) => { /* this is called for both keydown and keyup events! */ });
</div>

<p>
   <b>on()</b> <i>adds</i> a listener.  It doesn't replace or
   remove existing listeners for the same event.  If there's already another
   event listener on the same object, the old listener and the new
   listener will both be called when the event occurs.  You can add any
   number of listeners this way.  This is especially useful if you're
   mixing packages written by different people, because it helps ensure
   that listeners from different packages can co-exist peacefully.
</p>
<p>
   There's variation of <b>on()</b> called <b>one()</b>, which
   adds a listener that only runs a single time.  The first time it's
   called, it runs normally, then the system automatically removes it.
</p>

<p>
   You can remove an event listener explicitly via the <b>off</b>
   method:
</p>
<div class="code">
   mainWindow.off("keydown");
</div>
<p>
   Calling <b>off()</b> with an event name simply removes all listeners
   for the given event name.  You can also remove a specific
   listener, by passing in the same function you used to set up the
   listener in the first place with <b>on()</b>:
</p>
<div class="code">
mainWindow.off("keydown", myListener);
</div>

<p>
   You can specify a "namespace" with each event created with <b>on()</b>.
   A namespace is specified after the event name, separated with a period (.).
</p>
<div class="code">
mainWindow.on("keydown.MyPlugin", (ev) => { /* handler */ });
</div>

<p>
   The point of the namespace is to identify the listener
   for later removal.  When you call <b>off()</b>, you can 
   use the same namespace qualifier to remove only the listener(s)
   created with that namespace:
</p>
<div class="code">
mainWindow.off("keydown.MyPlugin");   // removes only the MyPlugin handler(s)
</div>

<p>
   Remember, the normal <b>off()</b> removes <i>all</i> listeners for the
   named event.  Using a namespace qualifier removes only the matching
   listeners.  This is especially useful for sharing code, because it
   lets you make nicely isolated code that won't interfere with other
   people's code that it's combined with.
</p>
<p>
   Using a namespace also lets you easily remove every event listener
   of every type that you installed under the namespace.  Just call <b>off()</b>
   with the namespace qualifier alone, with no event name:
</p>
<div class="code">
mainWindow.off(".MyPlugin");  // removes every mainWindow event with a .MyPlugin namespace
</div>
   

<h2>Object References</h2>

<p>
   <b>mainWindow:</b>  Represents the main user interface window object
   (the "playfield" window).  This window is the event target for most
   UI-related events.
</p>
<p>
   Events:
</p>
<ul>
   <li><b>keydown:</b> keyboard events while the application has focus
   <li><b>keyup:</b> keyboard events while the application has focus
</ul>

[TO DO - more objects]

<h2>Event Reference</h2>

<p>
   Every event listener function receives an <i>event</i> argument,
   which is an object containing information about the event.  All
   event objects have some common properties and methods:
</p>

<ul>
   <li><b>bubbles:</b>  A boolean indicating if the event "bubbles".  Bubbling
       is a concept from the Web browser event model, indicating if the event
       is sent to parent HTML elements after being sent to the one where it
       actually occurs.  This doesn't currently apply to any PinballY objects,
       so this property is always false, but it's included in the object for
       the sake of familiarity and in case it becomes relevant in the future.

   <li><b>cancelable:</b>  A boolean indicating if the event can be canceled.
       If true, Event.preventDefault() can be used to stop the default system
       action from occurring; if false, the system action will always occur
       whether or not you call preventDefault().  (This is read-only; you can't
       change it for a system event.)

   <li><b>defaultPrevented:</b>  Returns true if preventDefault() has been called
      on the event, false if not.

   <li><b>preventDefault():</b>  Call this method to tell the system to skip the
      normal default processing for the event.  This will have no effect unless
      the event can be canceled, as indicated by the <b>cancelable</b> property.

   <li><b>stopPropagation():</b>  Stop "bubbling" for the event.  This prevents
      the event from being dispatched to listeners in parent objects, if the
      event bubbles from child to parent.  This doesn't affect other event
      listeners on the same target; use stopImmediatePropagation() to prevent
      any other listeners from being called.  No current
      PinballY events use bubbling, so this currently has no effect.

   <li><b>stopImmediatePropagation():</b>  Stop propagating the event to any
      other listeners.  This prevents any other listeners registered in the
      same event target from being called after this listener returns.  (Other
      listeners that were already called <i>before</i> this listener was
      invoked obviously aren't affected, as they can't be "un-called".)
      If the event uses bubbling (dispatching the event to parent objects),
      this also stops any parent object listeners from being called.
       
   <li><b>timestamp:</b>  A number containing the Date.now() value when the
       event was fired.
       
   <li><b>type:</b>  A string with the name of the event ("keydown", "keyup", etc)
</ul>

<p>
   Individual event types add their own properties as well, described
   below.
</p>

<p>
   <b>keydown, keyup:</b>  These events are used with the <b>mainWindow</b>
   object. The keydown event fires when the user
   presses a keyboard key.  If the user holds down the key long enough
   for the key to start auto-repeating, another keydown event is fired
   on each auto-repeat.  keyup fires when the user releases a key.
</p>
<ul>
   <li><b>background:</b> true if the application was in the background when
       the event occurred, false if not.  PinballY processes key presses
       that occur while it's in the background so that it can monitor
       "Exit Game" and "Pause Game" command keys while a game is running.
   <li><b>code:</b> A string representing the key pressed, using the same
       naming as in standard Web browser keydown messages.  See, for
       example, <a href="https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key/Key_Values">Key Values (MDN)</a>.
   <li><b>key:</b> A string representing the key pressed, using the same
       format used in Web browser keydown messages.  For printable characters,
       this is the character itself, with shift key status applied (e.g.,
       holding down shift and pressing the "2" key produces a keydown event
       with key set to "@").  For special characters (cursor keys, F-keys, etc),
       this uses the standard browser name for the key, usually the same
       name as in <b>code</b>.
   <li><b>location:</b>  A keyboard location code for the key:
   <ul>
      <li>KEY_LOCATION_STANDARD (0), standard location used by most keys
      <li>KEY_LOCATION_LEFT (1), the left key of a paired modifier key (Shift, Control, Alt, Meta)
      <li>KEY_LOCATION_RIGHT (2), the right key of a pair modifier key
      <li>KEY_LOCATION_NUMPAD (3), the numeric keypad
   </ul>
   <li><b>repeat:</b>  true if this is an auto-repeat key event from a key being held down, false if not
   <li><b>vkey:</b>  A number representing the Windows "virtual key code" value for the key
</ul>

<p>
   Note that the common Web browser "which", "keyCode", and "charCode" properties
   are all missing.  That's because these were always problematic and poorly
   defined.  I didn't want to add to that mess with yet another ad hoc
   variation.  All modern browsers have  moved to the better-defined "code" and
   "key" system, which provides more complete and consistent information.
   The PinballY-specific "vkey" value is provided in case you really want
   the low-level Windows event information, but you'd really be better off
   in nearly all cases using the code and/or key values.
</p>

[TO DO - more event types]
   

<h2>EventTarget reference</h2>

<p>
   <b><i>eventTarget</i>.addEventListener(<i>event</i>, <i>listener</i>, <i>options</i>):</b>
   Adds an event listener.  <i>event</i> is a string giving the name of the event
   (e.g., "keydown").  <i>listener</i> is a function to call when this event occurs;
   the function takes a single parameter, an Event object that describes the event.
   <i>options</i> is an object with the following members:
</p>
<ul>
   <li><b>capture:</b> A boolean indicating whether the listener should be added to the
   "capture" stage or the "bubble" stage of processing for the event.  This isn't
   currently used, as no PinballY events distinguish these phases.

   <li><b>data:</b> Any value.  This will be passed to the event listener in
   <i>event.data</i> (the "data" property of the Event object parameter) each
   time this listener is invoked.  This can be used to store context information
   for the event listener.

   <li><b>once:</b>  A boolean.  If true, the listener is automatically removed
   (as though by calling removeEventListener()) the first time it's called.  Use
   this to create a listener that only handles the first event it receives.
</ul>
<p>
   The <i>options</i> parameter can be omitted, in which case default options
   are used.  For the sake of those familiar with the analogous Web browser
   method, <i>options</i> can also be passed as a boolean (true/false), in which
   case it specifies the value of the "capture" property.
</p>

<p>
   <b><i>eventTarget</i>.dispatchEvent(<i>event</i>):</b>
Calls the registered event listeners for the given event.  The <i>event</i>
argument is passed as the parameter to each listener invoked, with the
event-specific properties (target, data) set appropriately for each call.
Returns true if the event's default system processing should proceed,
false if not.  Returning false usually means that <i>event</i>.preventDefault()
was called in the course of processing the event.
</p>

<p>
   <b><i>eventTarget</i>.off(<i>events</i>, <i>listener</i>):</b>
   Removes event listeners previously registered with on() or addEventListener().
   As with on(), <i>events</i> is a string listing one or more event names,
   separated by spaces.  And as with on(), namespaces can be specified in
   the event names with ".namespace" suffixes ("keydown.MyPlugin", for example).
   The <i>listener</i> argument is optional; if provided, only listeners
   originally added using the same function will be removed, otherwise all
   listeners matching the event name and namespace values will be removed.
</p>
<p>
   When namespaces are specified, <i>any</i> namespace match from the original
   on() call will match.  You don't have to match the whole list specified in on().  For example,
   if an event listener was registered as <b>target.on("keydown.MyPlugin.Main", func)</b>,
   <i>any</i> of these calls will remove it: <b>target.off("keydown.MyPlugin")</b>,
   <b>target.off("keydown.Main")</b>, <b>target.off("keydown.MyPlugin.Main")</b>,
   <b>target.off("keydown.Main.MyPlugin")</b>.

<p>
   <b><i>eventTarget</i>.on(<i>events</i>, <i>data</i>, <i>listener</i>):</b>
   Adds an event listener.  <i>events</i> is a string listing one or more
   events, separated by spaces (for example, "keydown keyup").  <i>data</i>
   is optional; if provided, it can be any type of value, and specifies a
   value that will be passed to the listener each time it's invoked in the
   "data" property of the event object, which is passed to the listener
   as its single function parameter.  <i>listener</i> is a function to call
   each time the event fires.
</p>
<p>
   The event name list can include "namespace" qualifiers for the events.
   A namespace is any arbitrary string appended after a "." to an event
   name, as in "keydown.MyPlugin".  You can specify multiple namespaces
   on a single event this way: "keydown.MyPlugin.Main".  The purpose of
   a namespace is to help identify the event in calls to off().  That
   method lets you specify namespaces the same way in the event(s) to be
   removed.  Namespaces are especially useful to create shared code
   modules that can be mixed and matched with other modules, since it
   makes it easier to manage your own module's listeners without
   affecting code from other unrelated modules.
</p>

<p>
   <b><i>eventTarget</i>.one(<i>events</i>, <i>data</i>, <i>listener</i>):</b>
   This works exactly like on(), but registers a one-time-only listener that
   will be removed the first time it fires.  If this registers listeners for
   multiple events, each event's listener will be set up as a separate
   once-only handler.  For example, if <i>events</i> is "keydown keyup", two
   listeners are registered, and each listener will be called once before
   it's removed.
</p>

<p>
   <b><i>eventTarget</i>.removeEventListener(<i>type</i>, <i>listener</i>, <i>options</i>):</b>
   Removes an event listener that matches the type, function, and capture setting
   used in a prior call to addEventListener() or on().  As in the Web browser analog
   of this method, the only <i>options</i> value used to match the listener
   is the "capture" property.  
</p>

<h2>Browser-like functions</h2>

<p>
   As mentioned above, many of the functions and objects that you'd
   find in a normal Web browser environment aren't actually
   part of Javascript.  Even so, PinballY provides equivalents
   for some of the most often used browser functions.
   PinballY also has some extensions with similar functionality, but
   tailored more to the PinballY environment.
</p>

<p>
   <b>alert(<i>message</i>):</b>  Shows a system dialog box with the given
   message text.  This pops up a standard modal Windows message box with an OK
   button, and pauses the script until the user dismisses the dialog.  This
   can be handy for script debugging, but it should be avoided for anything
   else, as it doesn't fit very well with PinballY's pin cab interaction
   style.  See message() for a friendlier alternative, and log() for another
   debugging option.
</p>
<p>
   <b>clearInterval(<i>id</i>)</b>:  Cancels an interval event created
   with setInterval().  The <i>id</i> value is the value returned from
   setInterval() when the event was created.  This removes the event and
   prevents any pending execution from occurring.  It's harmless to
   cancel an interval that doesn't exist or that has already been canceled.
</p>
<p>
   <b>clearTimeout(<i>id</i>)</b>:  Cancels a pending timeout event
   created with setTimeout().  The <i>id</i> value is the value returned
   from setTimeout() when the event was created.  This removes the event
   and prevents any pending execution from occurring.  It's harmless
   to cancel a timeout that doesn't exist or that has already been canceled.
   This will also have no effect if the timeout has already been executed,
   since you can't "take back" the previous execution.
</p>
<p>
   <b>log(<i>message</i>):</b> Writes the message text to the PinballY log file.
   A newline (line break) is always added at the end of the message, so it's
   not necessary to include one in the string.  This can be useful for
   debugging, especially for cases where you want to log some information
   repeatedly and don't want to bother the user with it every time.
   (This is a PinballY extension, not a typical browser function.)
</p>
<p>
   <b>message(<i>message</i>, <i>style</i>):</b>  Shows a message using a
   graphical popup box in the main PinballY playfield window.  Unlike alert(),
   this doesn't pause the script until the user acknowledges the message;
   this simply shows or queues the message and returns immediately.  This
   is a good option for showing error messages or status updates, since it
   doesn't interrupt the flow of the user interface with a modal dialog.
   If <i>style</i> is provided, it's a string value specifying the
   visual style of the popup message.  This can be "info", "warning", or
   "error", which show the message with green, orange, and red trim
   (respectively), to visually reinforce the nature of the message.  The
   regular "info" style is used if <i>style</i> is omitted.
   (This is a PinballY extension, not a typical browser function.)
</p>
<p>
   <b>setInterval(<i>function</i>, <i>interval_in_milliseconds</i>)</b>:  Sets
   up an interval event, which invokes the given function periodically, at
   (approximately) the specified interval.  Each the time function is invoked,
   the internal event timer is automatically reset so that the event will
   be called again after another interval of the same time elapses.  The
   function returns an ID value that can be used to cancel the repeating
   event via clearInterval().  Like Javascript in a browser, PinballY's
   Javascript is single-threaded, so an interval event can't "interrupt" an
   executing script; if the next scheduled event time happens to occur
   while another script is executing, the interval function will be invoked
   when the current script finishes.
</p>
<p>
   <b>setTimeout(<i>function</i>, <i>timeout_in_milliseconds</i>)</b>:  Sets
   up a timeout event, which invokes the given function once, after the given
   interval elapses.  The function returns an ID value that can be used to
   cancel the timeout before it executes via clearTimeout().  As with
   Javascript in a browser, PinballY's Javascript is single-threaded, so
   timer events can't "interrupt" other scripts.  If the timeout period
   elapses while another script is running, the function will be invoked
   when the current script finishes.
</p>

<a name="multipleFiles"></a>
<h2>How to use multiple script files</h2>

<p>
   By default, PinballY only loads one file, Scripts\main.js.  But that
   doesn't mean that you have to cram all of your scripting code into that
   one place.  You can use the standard Javascript ES6 <b>import</b>
   command to load additional modules.  This lets you mix and match
   feature modules created by other users, and lets you create your
   own individual feature modules to share.
</p>
<p>
   (Don't confuse the Javascript ES6 <i>import</i> command with the
   DLL import mechanism described below.  The DLL import system is
   a PinballY add-on, not standard Javascript.  The standard <b>import</b>
   command imports other Javascript files, whereas the DLL import
   scheme lets you access native code in external DLLs.)
</p>
<p>
   The import system is specifically
   designed to make it easy to combine code written by different people,
   by letting you say exactly which symbols (and only those) are shared
   among modules.  That avoids all sorts of problems that <i>usually</i>
   come up when people try to share code, such as when two people
   both used the same names for their variables and functions.
</p>
<p>
   The basic Javascript import syntax looks like this:
</p>
<div class="indented">
   import { <i>function-or-object-name</i> } from "<i>module.js</i>";
</div>
<p>
   You can import multiple symbols from the module by listing them
   inside the braces, separated by commas.
</p>
<p>
   There's a lot more to the "import" syntax than this, including a
   dynamic form (the import() function) that lets you import code
   conditionally or at specific points in time.  Refer to a Javascript
   language reference for full details.
</p>

<h2>Calling external DLL functions</h2>

<p>
   You can call native code in external DLLs through PinballY's <b>dllImport</b>
   object.  (Oof, that's full of ambiguous looking letters, isn't it?  That's
   D-L-L-Import, DLL standing for Dynamic Link Library.)
</p>
<p>
   DLL Importing can be used
   to make calls directly to most Windows API
   functions from Javascript, to access system functionality beyond what's
   provided through the Javascript classes provided in PinballY.  You can
   also use it to call your own custom code written in any other programming
   language that can create DLLs, such as C, C++, Visual Basic, or C#.
   This creates almost unlimited customization and extension possibilities.
</p>
<p>
   This DLL import scheme, by the way, is a PinballY add-on.  You
   won't find it in Web browsers or in standard Javascript.  (Which
   also means you won't be able to read about it in other Javascript
   manuals; you'll have to make do with the material here.)
</p>
<p>
   The obvious warnings about calling out to native code apply: simple
   errors in native code calls can crash the whole program, and it's
   even possible to destabilize the system, corrupt disk files, or do
   other system damage.  Javascript and PinballY can't do much to
   protect against errant calls through the DLL layer because the
   whole point is to give you complete control.
</p>
<p>
   <b>Binding a function:</b>  
   To call an external DLL function, you first have to "bind" the DLL
   function.  This step connects the native code to Javascript.  You
   tell the system the name of the DLL you want to call, the name
   of the function in the DLL, and the "type signature" of the
   function, meaning the datatypes of the arguments and
   return value.  The bind operation uses that information to load
   the DLL into memory (if it's not already loaded), look up the
   native code address of the function, and create a Javascript
   function that represents the native code function. 
</p>

<div class="code">
let GetDesktopWindow = dllImport.bind("User32.dll", "HWND GetDesktopWindow()");
</div>

<p>
   The return value from the bind() call is a callable Javascript function
   that invokes the native code.  You can simply store this in a Javascript
   variable for later use.  In this example, I've given my Javascript
   variable the same name as the native function, but that's not in any
   way required - you can call the variable whatever you want.  I just
   like to use the same name to help keep things straight.
</p>
<p>
   The first argument to bind() is the name of the DLL, in this case
   the standard Windows library User32.dll, which contains many of the
   basic UI functions in Windows.  The second argument is the declaration
   of the function's return type and argument types using "C" programming
   language syntax.
</p>
<p>
   PinballY uses C syntax for the function declarations primarily
   because that's what's the Microsoft API documentation uses almost
   everywhere.  This
   makes it easy to copy and paste API definitions from the SDK
   documentation directly into your Javascript code, often with no
   changes.  The C syntax is used in all cases, even if you're using
   a DLL written in some language other than C.  You can't substitute VB
   or C# syntax; you have to translate it to C terms.
</p>

<p>
   Once a DLL function is bound, you invoke the DLL function simply
   by calling the Javascript function returned from the "bind" call.
</p>

<div class="code">
let hwndDesktop = GetDesktopWindow();
</div>

<p>
   PinballY uses the C type signature that you provide in the "bind"
   call to automatically convert arguments from Javascript format to
   the native format when you call the bound function.  It likewise
   converts the results from native format back to
   Javascript format on return.  That means you don't have to worry too
   much about the type conversion details when you call a bound DLL
   function; you can mostly just treat it like any other Javascript function.
</p>

<p>
   You can bind several functions in the same DLL at once, by specifying a
   list of strings instead of a single function name.  When you provide a list
   of function signatures to bind, you get back a corresponding list of bound
   functions, so you can use Javascript's destructuring syntax to assign
   them to a list of variables in one shot:
</p>

<div class="code">
let [GetDesktopWindow, GetWindowRect] = dllImport.bind("User32.dll", [
    "HWND GetDesktopWindow()",
    "BOOL GetWindowRect(HWND, LPRECT)"
]);
</div>

<p>
   <b>Type conversions:</b>  The DLL importer will automatically
   perform the normal Javascript type conversions as needed for simple
   types.  For example, if a DLL function requires a 32-bit "long"
   integer argument, and you can pass in a Javascript number, it'll be
   converted to the native integer type automatically.  If you pass
   in a string for that same 32-bit integer, the string will be
   converted to a number as usual in Javascript, and that will then
   be converted to the native integer type.
</p>
<p>
   When the DLL function calls for a C "struct" type, the importer
   will automatically map a Javascript object argument to the struct
   type, by matching the property names to the struct field names.
   Any missing struct fields will be filled in with default
   values (0 for integer types, null for pointer types).
</p>
   
<p>
   <b>Defining struct types:</b>
   Many Windows API functions use C "struct" (structure) types as
   arguments.  For example, the GetWindowRect() API function takes
   a pointer to a RECT structure, which has elements for the
   corner coordinates of the window.  Before you can use a struct
   type in a function binding, you have to define the struct type,
   so that PinballY knows how the structure's internal memory is
   laid out.  As with the function declaration itself, you use
   standard C syntax to define a structure.  This requires a
   separate <b>define()</b> method call:
</p>
<div class="code">
dllImport.define("struct RECT { LONG left; LONG top; LONG right; LONG bottom; }");
</div>

<p>
   The define() method doesn't return anything.  It just parses the
   type definition and adds it to an internal table of type names
   inside the dllImport object.  Once the type is entered into the
   internal table, you can use it in subsequent bind() calls.
</p>

<p>
   The define() call above uses <i>almost</i> the same syntax that Windows
   SDK documentation uses for RECT.
   But they actually take this one step further, by defining a couple
   of "typedef" types for the structure.  typedef is a C language
   feauture that creates a global alias for a type.  It simply adds a
   new global name for the type that you can use in other places, such as
   in function declarations.  Here's a revision to the above, using the
   full typedef that the SDK uses:
</p>
<div class="code">
dllImport.define("typedef struct _RECT { LONG left; LONG top; LONG right; LONG bottom; } RECT, *PRECT");
</div>

<p>
   That idiom is extremely common in the Windows SDK headers.  Most Windows structs have similar typedefs
   of the form "typedef struct _FOO { ... } FOO, *PFOO".
   That defines the struct itself with a dummy "underscore" name (_FOO), plus a global alias for
   the struct with the plain name (FOO), plus a global alias for a pointer to the struct with the
   "P" prefix name (PFOO).  There's almost always an additional typedef for "LPFOO", which
   is the matching "long pointer" to the struct.  The distinction between "long pointers"
   and regular pointers is an obsolete concept from the 16-bit days of Windows 3.1; on
   all current platforms, PFOO and LPFOO have identical definitions.
   But the "P" and "LP" variations are still defined for most types, and they're still used
   in the API function definitions, because Windows is the roach motel of typedefs.
   So we might as well make one more revision to add the "LP" version and get the complete set:
</p>
<div class="code">
dllImport.define("typedef struct _RECT { LONG left; LONG top; LONG right; LONG bottom; } RECT, *PRECT, *LPRECT");
</div>

<p>
   For long struct definitions, you might prefer to use Javascript's back-quote string
   style, which lets you embed newlines in strings.  That lets you skip the manual work
   of pasting all the lines together when copying from SDK documentation, and also makes
   the result a lot more readable.
</p>
<div class="code">
dllImport.define(`
typedef struct _STARTUPINFOW {
  DWORD  cb;
  LPWSTR lpReserved;
  LPWSTR lpDesktop;
  LPWSTR lpTitle;
  DWORD  dwX;
  DWORD  dwY;
  DWORD  dwXSize;
  DWORD  dwYSize;
  DWORD  dwXCountChars;
  DWORD  dwYCountChars;
  DWORD  dwFillAttribute;
  DWORD  dwFlags;
  WORD   wShowWindow;
  WORD   cbReserved2;
  LPBYTE lpReserved2;
  HANDLE hStdInput;
  HANDLE hStdOutput;
  HANDLE hStdError;
} STARTUPINFOW, *LPSTARTUPINFOW;
`);
</div>

<p>
   <b>Namespaces:</b>  When you define a struct or other type via dllImport.define(),
   it goes into a single, flat namespace within the dllImport object.  For most Windows
   SDK headers, that's fine, because the SDK takes pains to give everything a unique
   name.  If you're mixing custom DLLs from different sources, though, you might
   run into cases where the same type names are used in more than one DLL.  In this
   case, you might have to create different "namespaces" for the DLLs.  This is
   fortunately pretty easy.  All you have to do is create a new DLL Import object,
   which you can do like this:
</p>
<div class="code">
var dllImport2 = new DllImport();
</div>
<p>
   Note the capitalization!  The default DLL import <i>object</i>, which you
   use to call the .bind() and .define() methods, is called
   <b>dllImport</b> with a small d.  The <i>class</i>, which you use with "new"
   to create new importer objects with their own namespaces, is called
   <b>DllImport</b> with a big D.  Javascript is picky about capitalization
   (as any serious programming language should be),
   so <b>dllImport</b> and <b>DllImport</b> are two separate entities.
</p>
<p>
   Once you create your new object, you can call dllImport2.define() to add structs
   to its namespace without affecting the structs in the original object's namespace.

<p>
   <b>Predefined type names:</b>  The DLL importer's C parser knows about
   all of the standard C types (int, long, float, etc) and the standard Windows
   SDK aliases for the basic types (INT, UINT, DWORD, etc).  It also pre-defines
   nearly all of the Windows HANDLE subtypes (HWND, HDC, HBITMAP, etc) and the
   common null-terminated string types (LPSTR, LPCTSTR, etc).  In normal C
   code, the "T" string types (LPTSTR, LPCTSTR) can be either ANSI (8-bit
   characters) or Unicode (16-bit characters), according to compiler options,
   but in PinballY Javascript, they're always Unicode.
</p>
<p>
   For a full, up-to-the-minute list of the predefined types, refer to the
   <b>primitiveTypes</b> constant object defined in <b>Scripts\System\CParser.js</b>.
   Any types that you need that aren't present can always be added in your script
   code via a call like this:
</p>
<div class="code">
dllImport.define("typedef int *ptrToInt");
</div>
<p>
   <b>Windows SDK "A" and "W" functions:</b>  Strangely, many of the common
   Windows API functions have slightly different names in the DLL than in
   the SDK documentation.  For example, there's no actual DLL function
   called MessageBox.  Instead, there are two variants of the functions,
   one called MessageBoxA and  one called MessageBoxW.  The "A" stands for
   ANSI (8-bit character strings), and the "W" is for WIDE (16-bit Unicode
   strings).
</p>
<p>
   Most Windows API functions that take character string arguments
   (directly or within structs) have these "A" and "W" variants.  If
   you run into any strange missing function errors, double-check the
   SDK documentation to see if the function you're trying to call
   needs an "A" or "W" suffix.
<p>
   In PinballY Javascript, it's best to use the "W" variants when you're
   faced with a choice.  Javascript itself uses Unicode for all strings
   internally, so you'll avoid unnecessary string conversions by using
   the "W" functions.
</p>
   
<p>
   <b>DLL filenames and paths:</b>
   When you bind a function, the DLL name you specify can be a plain filename,
   such as the "User32.dll" we've been using in our examples, or it can use a
   full, absolute path.  In the absence of a
   path, Windows will look in the PinballY program folder for the DLL and
   then in the standard Windows system folders.  That makes it a no-brainer
   to always use plain filenames (with no path) for all standard Windows DLLs.
   Custom DLLs of your own are also best loaded with no path name, as
   a path name will create headaches if you ever move any files around.
   It's best to copy your custom DLLs into the PinballY program folder
   to ensure that they can be found without having to specify any
   paths.
</p>

<h2>Browser frameworks (jquery, etc)</h2>

<p>
   Web Javascript frameworks like jQuery generally <b>won't</b>
   work in PinballY.  That's because Web browser frameworks
   depend heavily on the Web browser HTML document structure and
   event model.  As we've already discussed, those don't exist in
   PinballY.  But jQuery in particular has influenced some of the
   pre-defined framework in PinballY's Javascript environment,
   so some of the concepts carry over in general terms, even if
   the exact details can't.
</p>

<h2>System script files</h2>

<p>
   Many of the classes, objects, and functions that constitute 
   PinballY's Javascript "application environment" are implemented
   in Javascript, so you can easily view the code to see what it's
   doing, in case you need any details beyond what's covered in
   this section.  You can even change the system code if you have
   some unusual situation that requires such drastic measures,
   although that's strongly discouraged, for the obvious reason that
   it will make it harder to update to a new release.
</p>
<p>
   PinballY's system scripts are in the <b>Scripts\System</b> folder
   within your PinballY program folder.  These files are automatically
   loaded when PinballY starts up (or, in some cases, later on when
   needed), so there's no need to copy any of these files into your
   own .js files or to load them explicitly with "import" or any
   other means.  You can simply expect these files to be available
   at all times.
</p>
<p>
   A quick summary of the files:
</p>
<ul>
   <li><b>SystemClasses.js:</b>  The main application environment
      classes, such as the <b>mainWindow</b> object and the 
      event handling classes.

   <li><b>CParser.js:</b>  Code that parses C-style function and
      struct definitions for use in the DllImport system.
</ul>

</body>
</html>
