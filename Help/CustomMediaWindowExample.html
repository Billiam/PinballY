<!DOCTYPE html>
<!-- This file is part of PinballY
 Copyright 2018 Michael J Roberts | GPL v3 or later | NO WARRANTY -->
<html>
<head>
   <title>PinballY Help</title>
   <link rel="stylesheet" type="text/css" href="main.css">
</head>
<body>
<script src="jquery-1.12.1.js" type="text/javascript"></script>
<script src="PinballYHelp.js" type="text/javascript"></script>

<h1>Custom Media Window</h1>

<p>
   Starting with version 1.1, PinballY lets you create your own
   additional "Media Windows" from Javascript.  A Media Window is
   essentially the same as any of PinballY's built-in secondary windows:
   the backglass window, DMD window, topper window, and
   instruction card window.  The only differences are that you
   create these windows with Javascript code, and you can specify
   what kind of media they use for their background images and
   videos.
</p>
<p>
   There are basically two steps to creating a custom window:
</p>
<ul>
   <li>The first step, which you can skip in some cases, is to create a "Media
   Type" descriptor for the window.  PinballY comes with a bunch
   of pre-defined media types that apply to the built-in windows:
   Table Image, Table Video, Backglass Image, Backglass Video, etc.
   Using Javascript, you can define additional media types of
   your own, so that you can add your own media files that go
   beyond the basic set that PinballY knows about by itself.
   For example, if you wanted to add a picture of the original
   pinball machine for each game, you could define a Pinball Machine
   Image media type.
   <p>
      New media types are created via
      <a href="GameList.html#createMediaType">gameList.createMediaType</a>.
   </p>
   <p>
      You can skip this step if you want the window to use one
      of the built-in media types (backglass images, for example;
      see <a href="MediaTypes.html">Media Types</a> for a full list),
      or if you don't want the window to automatically display
      any background media at all.  You might omit automatic
      background media if you were going to program completely
      custom graphics for the window using  <a href="DrawingLayer.html">Drawing Layers</a>, for example.
   </p>

   <li>The second step is to create the window itself.  This is
   done by calling
   <a href="MainWindowObject.html#createMediaWindow">mainWindow.createMediaWindow()</a>.
   This lets you specify the type of media the window will display
   automatically.  You can specify a background image type,
   a background video type, or both.
</ul>
<p>
   Once the window is created, it acts like the backglass window
   and the other built-in windows.  You can use the mouse to
   size it and position it where you want it, and PinballY will
   automatically save and restore that position across sessions.
   Whenever you navigate to a new game in the wheel UI, PinballY
   will automatically load the game's background image or video,
   according to the media types you specified when creating
   the window.
</p>
<p>
   Custom windows have full support for <a href="DrawingLayer.html">Drawing Layers</a>,
   so you can go beyond this simplest use of just displaying loading per-game
   images and videos, by creating custom graphics through Javascript.
   We'll see how to do that later in this section.
</p>
<p>
   The rest of this section goes through a few ideas for how
   you can use custom windows, showing how to implement each one.
   We'll start with the simplest things to implement and build
   on that as we go.
</p>


<h2>Wheel icon window</h2>
<p>
   Some pin cab builders get especially creative with embedding
   monitors in unique places in their cabs.  A great example is
   <a target="_blank" href="https://www.vpforums.org/index.php?showtopic=44487">Vanlon's <i>CANNONBALL!</i> pin cab</a>,
   which features a 5" <b>circular</b> (!) display panel embedded in a
   custom 3D-printed cannon topper.  It's one of the best examples
   of a themed topper I've seen.  If you have a unusual extra monitor
   like this, you'll obviously want to take advantage of it at
   every opportunity, so this would be a great place to use a
   custom window.
</p>
<p>
   For a monitor with such a small display area, the wheel icon
   might make a good choice for the graphics to display.
</p>
<p>
   This is an especially easy example to implement, because
   PinballY already knows about wheel images.  All we have to
   do is create a custom window that uses wheel images as
   its background image type.
</p>
<p>
   But how do we say that we want
   to use "wheel images" in concrete terms?  By referencing
   the "wheel image" media type.  A media type is a data record
   inside PinballY that has all of the information about something
   like the wheel icons: what kind of file formats they use
   (PNG, etc), which directory they're stored in, and so on.
   PinballY has a bunch of media types built in - one for each
   of the media items that you can use in the system windows,
   such as playfield images, backglass videos, and so on.
   For a list of the built-in types, see <a href="MediaTypes.html">Media Types</a>.
</p>
<p>
   Each media type has an ID that we can use to refer to it in Javascript.
   (You'll find that in the table of built-in types linked above.)
   For wheel images, the ID is "wheel image".  So to create our
   custom window that always shows the current wheel image, we
   just have to use mainWindow.createWindow() and specify
   "wheel image" as the background image type.
</p>
<div class="code">
// Create the window, using the "wheel image" media type for the
// background image
let wheelIconWin = mainWindow.createMediaWindow({
    title: "Wheel Icon",
    configVarPrefix: "customWindow.WheelIcon",
    backgroundImageMediaType: "wheel image",
});

// Use the "zoom" scaling mode for this window, to keep the icon's
// original aspect ratio (rather than stretching it to fit the
// whole window)
wheelIconWin.backgroundScalingMode = "zoom";
</div>
<p>
   Apart from the background image, the only other details we had
   to specify for the new window were its title and its "configuration
   variable prefix".
</p>
<p>
   The title is what's displayed in the title bar,
   and it also appears in some system menus.  It's just there to
   identify the window to you in those contexts, so you can pick
   whatever name you like for it.  There's no need for the title
   to be unique or use any special format, but you probably
   shouldn't make it completely empty, since it might be confusing
   in menus.
</p>
<p>
   The config variable prefix, on the other hand, does have some
   special requirements for its format.  It should be mostly alphanumeric,
   but you can also safely use periods, hyphens, and underscores.
   <b>Don't</b> use any spaces, and don't use any other special
   characters or punctuation, because this string will go into
   the configuration file (Settings.txt) several times.  This string
   is used as the prefix for all of the settings variables that
   pertain to this window - that's where PinballY stores the
   window's location, visibility, and layout information between
   sessions.  I personally like using "customWindow" as a prefix
   to the prefix, just to make it obvious when looking at the
   settings file that it's one of our custom windows that we
   defined through Javascript.  That's not a requirement, just
   something I think might be helpful down the road if you
   ever look at the settings file to troubleshoot some other
   problem, say.  Then after that "customWindow" prefix, add
   some description of the window, in this case "customWindow.WheelIcon".
   Again, if you ever have to look at the settings file later
   on, it'll be helpful if you choose a name for this that
   makes some kind of sense to you and that will job your
   memory in the future.
</p>
<p>
   The final detail in this example is that we've set the
   <a href="CustomWindow.html#backgroundScalingMode">background scaling mode</a>
   for the window to "zoom".  The default scaling mode is "stretch",
   which stretches out the image to exactly fill both the
   width and height of the window, even if that requires
   distorting the image geometrically.  That's the default
   because it's usually what you want for things like
   backglass images, where it's more important (to me, at least)
   to fill the available space than to maintain the geometry
   of the original image.  But for wheel icons, we're not
   going to fill the whole space anyway, so it seems
   better to maintain the original aspect ratio.
   The "zoom" option sizes the image so that it's as large
   as possible without exceeding either the width or height
   of the window and without any geometrical distortion.
</p>

<p>
   We could embellish this example just a little by adding a custom
   background color.  Wheel icon images are usually transparent
   PNGs - the area around the icon is usually left transparent
   so that a background image (usually the playfield image or
   video) can show through.  The wheel icon <i>is</i> the background
   image in this case, so there's nothing behind it other than
   the default black background that the system draws.
   If we wanted to choose a different background color, we
   could use a custom drawing layer.  The trick is to use a
   negative Z index so that the drawing layer goes behind
   the main "system" media layer where the wheel icon will
   be loaded.
</p>
<div class="code">
let wheelIconBackground = wheelIconWin.createDrawingLayer(-1);
wheelIconBackground.clear(0xffff00ff);
</div>
<p>
   0xffff00ff is opaque bright purple. (The first "ff" is the opacity,
   and the next six numbers, ff 00 ff, give the red, green, and blue
   components.  FF is programmer speak, or more technically
   hexadecimal, for 255, which is the maximum brightness for
   each color component.  So we have maximum opacity, maximum
   red, maximum blue, and zero green.  That makes bright purple
   in the RGB color scheme.)
</p>


<h2>Flyer window</h2>
<p>
   Most of the HyperPin media packs that you
   can find on the virtual pinball sites (such as
   <a target="_blank" href="https://vpforums.org">vpforums</a> or
   <a target="_blank" href="https://vpuniverse.com">vpuniverse</a>)
   include scanned copies of the machines' original advertising flyers.
   PinballY has a command for viewing the current game's
   flyer as a popup in the main window, but if you have some extra
   display space, you could set up a separate window dedicated to
   displaying the flyer.
</p>
<p>
   As with the Wheel Image window above, it's simple to set this
   up in a custom window since PinballY already has a built-in
   media type for Flyer Images.  In this case, the identifier
   for the media type is "flyer image".
</p>
<div class="code">
// Create the window, using the "wheel image" media type for the
// background image
let flyerWin = mainWindow.createMediaWindow({
    title: "Flyer",
    configVarPrefix: "customWindow.Flyer",
    backgroundImageMediaType: "flyer image",
});

// Flyers use a wide range of shapes, from regular "portrait
// mode" letter-sized pages to "landscape mode" pages to
// two-page or multi-page fold-out spreads.  So I think it's
// best to preserve the original aspect ratio.
flyerWin.backgroundScalingMode = "zoom";
</div>

<p>
   That much is just like setting up the Wheel Icon window in
   the last example.  But Flyers have a little bit of a difference
   form wheel icons, as a media type: Flyers can come in sets
   rather than single images.  Many of the original advertising
   flyers were printed on double-sided pages, or came as a fold-out,
   two-page spread, and some were more like little brochures.
   It wouldn't be very usable if the HyperPin media packs
   stitched all of those pages into a single JPEG image,
   most of the media packs come with a separate JPEG image
   for each Flyer page.  Instruction cards in the HyperPin
   media packs are also often provided in sets, since most
   arcade pinball machines came with several sets of
   instruction cards with variants of the rules that the
   operator could choose from.
</p>
<p>
   So how do we handle the multiple Flyer pages?  If we look
   to the way PinballY handles flyer displays itself, we see
   that PinballY lets the user scroll through the collection
   using the flipper buttons.  That works for PinballY's
   standard flyer display because that happens in a popup box.
   Popup boxes are modal, which means we can use the flipper keys in
   that context for something other than their usual meaning
   (usual in PinballY, anyway) of switching games.  That
   obviously won't work for a separate window that's always
   displayed.  For that, we're going to need another approach.
</p>
<p>
   Before we get to how to handle the user interface aspect
   of this, I should mention how we handle it at the Javascript
   level.  That much is easy: the custom window has a special
   property for it, <a href="CustomWindow.html#pagedImageIndex">pagedImageIndex</a>.
   Reading this property tells you the current image being displayed,
   as a number starting at 0 for the first image in the current
   game's collection.  Setting the property to a new value changes
   to the selected image.  One easy way to use the property is
   to treat it as a way to scroll forwards and backwards through
   the image collection, by incrementing or decrementing it.
   The system automatically "wraps" the value when you go past
   the beginning or end of the list, so there's no need to do
   any bounds checking; just increment and decrement away.
</p>
<p>
   Now, back to the UI.  One way to handle it would be to assign
   some keyboard keys to scroll through the flyers.  If you have
   a couple of spare buttons available, this is just a matter
   of setting up a <a href="KeyEvent.html#keydown"><b>keydown</b></a>
   event handler that adjusts the pagedImageIndex property:
</p>
<div class="code">
mainWindow.on("keydown", ev => {
    if (ev.code == "KeyH")
        flyerWin.pagedImageIndex += 1;
    else if (ev.code == "KeyG")
        flyerWin.pagedImageIndex -= 1;
});
</div>
<p>
   Here we've arbitrarily chosen the "G" and "H" keyboard keys,
   but you can easily change those to any available keys on your cab.
</p>
<p>
   You could also do this with a menu command instead of directly
   through the keyboard, although that seems so inconvenient to me
   that I'm not going to bother working out the code for it.  Many
   of the other Worked Examples sections have menu examples that
   you should be able to easily adapt.
</p>
<p>
   Another approach that avoids the keyboard is to flip the pages
   automatically on a timer, say every five seconds.  This would work
   like the automatic High Score display rotation in the DMD window.  This
   is pretty easy:
</p>
<div class="code">
setInterval(() => { flyerWin.pagedImageIndex += 1; }, 5000);
</div>
<p>
   Remember that <a href="SystemFunctions.html#setInterval">setInterval()</a>
   takes its time period in milliseconds, so we tell it to run this
   function every 5000 ms, which is the same as 5 seconds.
</p>
<p>
   We could improve this timed approach slightly by taking note of
   when a game switch occurs, and resetting the interval timer when
   that happens.  Without that, the running timer will just keep
   running every five seconds, so it might jump in and change to
   the second page only a fraction of a second after a game switch,
   if that just happens to be its next scheduled run time.  We
   could make this a little smoother by clearing the old interval
   timer and setting up a new one each time a game switch occurs.
</p>
<div class="code">
let flyerTimer;
gameList.on("gameselect", ev => {
    clearInterval(flyerTimer);
    flyerTimer = setInterval(() => { flyerWin.pagedImageIndex += 1; }, 5000);
});
</div>

<p>
   It's worth noting that this multiple media problem applies to PinballY's own
   Instruction Cards window, but that window ignores this issue completely.
   In the case of the instructions, I assumed that the virtual cab
   owner is going to treat the collection of cards provided in
   the HyperPin pack exactly the same way that an arcade operator
   would have treated the collection of cards that came with
   a physical pinball machine: they're going to pick the one
   with the rule set they prefer, and display that one card.
   In the case of the arcade operator, you'd take the card
   out of the pack and pop it into the machine's apron.
   For the virtual cab owner running PinballY, you just
   rename the version of the card that has your preferred
   instruction set so that it's the un-numbered card in
   the folder.
</p>


<h2>Original pinball machine picture window</h2>
<p>
   So far our examples have all worked with "standard" media
   types that come with the HyperPin media packs and that
   PinballY already knows about.  Now let's look at how you
   can extend the idea to entirely new media categories
   that aren't part of the standard HyperPin collection.
</p>
<p>
   One idea that comes to my mind is that it might be nice
   to see a picture of the original pinball machine - the
   whole machine as it would have looked in an arcade.
   A lot of machines have rather nice cabinet artwork
   that we never see during virtual play.
</p>
<p>
   What's different about this example is that we can't
   rely on one of the pre-defined media types when we create
   our window.  PinballY simply doesn't include a built-in
   type for whole-machine pictures.  But PinballY does let
   us define our own new types to supplement the built-in
   types it knows about.  We do this through a method
   on the <a href="GameList.html">gameList</a> object
   called <a href="GameList.html#createMediaType">createMediaType()</a>.
</p>
<p>
   Defining a new media type is a matter of filling in all of
   the information that PinballY keeps internally for its own
   built-in media types:  where to look for a game's
   files of that type, what file formats they use, and how to
   refer to them in the UI.  You can read about all the details
   in <a href="MediaTypes.html">MediaTypes</a>, so we'll
   just show the code needed for our "pinball machine picture"
   example.
</p>
<div class="javascript code">
gameList.createMediaType({
    name: "Cabinet Image",
    id: "cab image",   // this is how we refer to the type later
    folder: "Cabinet Images",
    format: "Image",
    extensions: ".jpg .jpeg .png",
    configId: "CabinetImage",
    perSystem: false,
    isIndexed: true
});
</div>

<p>
   Most of this is pretty straightforward (at least, it should be
   after reading through the <a href="MediaTypes.html">MediaTypes</a>
   section), but there are a couple of things worth pointing out:
</p>
<ul>
   <li>We set <b>perSystem</b> to false, which makes
   our cabinet images "generic".  That means that the media folder
   will only contain one set of images for, say <i>Medieval Madness</i>,
   which will be used for <i>any</i> virtual version of the game
   based on any pinball simulator system, from Visual Pinball to
   Future Pinball to FX3.  This seems to me like the right call
   for cabinet images, since this is something that refers back
   to the original machine being simulated, rather than to
   something unique to each simulator.  The built-in types for
   Instruction cards and Flyers work the same way, for the same
   reason.

   <li><b>isIndexed</b> is set to true, which means that we can
   have multiple cabinet images for each table.  The files are
   distinguished in the media with numeric suffixes:
   "Medieval Madness (Williams 2004) 1.jpg",
   "Medieval Madness (Williams 2004) 2.jpg", and so on.  There
   can also be a plain "Medieval Madness (Williams 2004).jpg"
   alongside those, without any number - if it's there, it
   counts as an implied "number zero" in the list.
   <p>
      The built-in type for Instruction Cards is also an indexed
      type, because many of the original machines came with a
      selection of cards with variations on the rules for the
      operator to choose from.  Many of the HyperPin media packs
      reproduce that full selection, and some also come with
      translated versions.  Flyers use a slightly different
      convention for multiple images, known as "paged" media
      (which sorts the multiple files into subfolders, rather
      than using a numeric suffix).  I think Cab Images are a
      good fit for the indexed type, since you might find
      several good ones for a given game, but there's no
      particular structure to them; they're just different
      takes on the same thing.  The "paged" folders that Flyers
      use are more appropriate when the images constitute
      parts of a whole.
   </p>
</ul>

<p>
   Once we've defined our new media type, the window creation is
   exactly like before.  The only difference is that we reference
   the new media type, using the <b>id</b> property we assigned when
   creating the type, in the part of the window descriptor where
   we specify the background image type.
</p>
<div class="code">
// Create the window, using our new custom Cabinet Image media type
// as the background image type
let cabPicWin = mainWindow.createMediaWindow({
    title: "Cabinet",
    configVarPrefix: "customWindow.CabImage",
    backgroundImageMediaType: "cab image"  // the "id" of the type
});

// maintain the original image proportions
cabPicWin.backgroundScalingMode = "zoom";

// since this is an indexed type, meaning there can be multiple
// cab images for each game, set up an interval timer to flip
// through them at a leisurely pace
let cabPicTimer;
gameList.on("gameselect", ev => {
    clearInterval(cabPicTimer);
    cabPicTimer = setInterval(() => { cabPicWin.pagedImageIndex += 1; }, 5000);
});
</div>

<p>
   Note that we created a timer to flip through the images,
   in case a given table has multiple cab images available.
   This works exactly like the one in the earlier Flyers example:
   we just increment the window's <b>pagedImageIndex</b> every
   few seconds to switch to the next available photo.
</p>

<p>
   <b>Installing media:</b> Now, one little detail remains,
   which is that you probably don't any cabinet images
   installed to test this out with.  The HyperPin packs
   don't include anything like this.  So you'll have to
   make a separate trip to the Web to find these.
</p>
<p>
   One reliable place to look is <a target="_blank" href="https://ipdb.org">IPDB</a>
   (the Internet Pinball Database). They have photos
   for most of the commercial pinball tables ever built,
   usually including at least one full-cabinet photo.
</p>
<p>
   The easiest way to install a cabinet photo from the Web
   is to drag it from the browser and drop it onto your
   custom window.  One of the nice things about the Media
   Type system is that it tells PinballY not only where to
   look for existing photos, but how to handle installation
   when you drop a new photo onto a window.  The system will
   automatically install a photo dropped on your custom
   Cabinet Images window as a Cabinet Image media item.
   You can also add photos directly into the media folder
   via the Windows desktop; see <a href="DirectoryInfo.html">Files &amp; Folders</a>
   for help figuring out where the images are actually stored.
</p>

<h2>Second apron card</h2>
<p>
   Many pin cab builders install an
   "apron" approximation at the bottom of their cab, below the
   main TV, as a filler to make room for the plunger and so on.
   A few cab builders have placed a small 6" or 7" monitor in
   that area, where the instruction card would customarily go
   on a real pinball machine.  That's where the idea for
   PinballY's built-in Instruction Card window came from: it's
   especially useful for these cabs with dedicated apron
   monitors, since you can position the window there to get
   a live instruction card view as you scroll through games
   (and even while playing).  But what if you have a <i>second</i>
   apron monitor, on the right side, where the pricing/replay score
   card would normally go?  PinballY doesn't have anything like
   that built in, but you could use a custom window to add a
   second window for that area.
</p>
<p>
   This was actually the original use case
   that got me thinking about adding custom windows!  A forum member on
   vpforums asked if there was a way to add a second score card, to
   fit his custom cab setup with two small monitors in the apron area.
   This is the first time I've heard of anyone installing <i>two</i> apron
   monitors, so I hadn't considered the idea of a second
   Instructions Card-like window before.  It seemed like a useful idea,
   but it also seemed really specialized, which got me thinking that
   what we really need is a way to create whatever additional
   windows you can think up to fit your cab's unique features.
</p>
<p>
   What should we display on a second apron monitor?  On a real
   pinball machine, the apron traditionally has an instruction
   card on the left, and a pricing card on the right:
   "1 Play = 75&cents;/3 balls per game", or something like that.
   We already have the Instructions Card covered, so that leaves
   the pricing card as the obvious choice.  But that probably
   isn't very interesting on a virtual pin cab, since it would
   say more or less the same thing for every game - "Free Play -
   Press Start".  That's not a very dynamic use for a monitor
   that can display whatever we want.
</p>
<p>
   A more interesting idea might be a High Scores display.  This
   might not be something you'd see on a modern machine, but it's
   useful, and it's actually not
   completely out of place historically.  In the really old days
   of electromechanical machines, some arcades commemorated high
   with a hand-printed note placed on the apron - a precursor
   of the automatic high score displays on modern electronic games.
   It was also common until the mid-1980s for the pricing
   card to include a list of Replay Score levels - not quite the
   same thing as high scores, but related.  Replay scores
   disappeared from the pricing cards after that, because it
   was easier to let the software announce them on the main
   display instead, especially since newer games can be set
   to automatically adjust the replay scores according to how
   often players reach them.
</p>
<p>
   PinballY already displays live high scores on the DMD using
   DMD-style graphics appropriate to the game's era, so we
   <i>could</i> just replicate that on another monitor.  But
   that would be a little boring.  I think it would be nicer
   to follow the black-on-white text style of the instruction
   card.
</p>
<p>
   Javascript has access to the high score information via the
   <a href="HighScoresEvent.html">highscoresready</a> event.
   That fires shortly after a new game is selected and provides
   an array of strings with the scores.  We can use that to
   build a custom image using a <a href="DrawingLayer.html">Drawing Layer</a>
   in the custom window.
</p>
<p>
   Since we're going to generate our own graphics, we don't need
   any automatic background media in this window.  We'll just fill
   the window with our custom text display.  This makes the custom
   window setup especially simple:
</p>
<p>
<div class="code javascript">
// Create the Score Card window.  This is an especially simple
// one, since it doesn't need to display any automatic media:
// all of the graphics will be custom drawn in Javascript.
let scoreCardWin = mainWindow.createMediaWindow({
    title: "Score Card",
    configVarPrefix: "custom.ScoreCard"
});
</div>

<p>
   The drawing code gets a little long-winded, but it's
   straightforward, so I'll explain how that works via inline
   comments rather than boring you with a lengthy intro.
   The only part that's tricky enough to mention up front
   is the way it draws the score
   card <i>twice</i>, as a way to figure the height of the
   text.  I took that route because the best way to measure
   the height of styled text with PinballY's drawing facilities
   is to actually draw the text, and see where that leaves
   the "text origin", which is sort of internal cursor.
   The height measurement is important
   because it lets us vertically center the overall text
   layout in the window, and it lets us figure the size
   of the canvas area we need to accommodate the text.  Some
   games have extremely long high score rolls
   (<i>Medieval Madness</i>, for example), so it's important
   to adjust the height dynamically to fit the text.
</p>

<div class="code javascript">
// Drawing layer for our generated score card image
let scoreCardLayer = scoreCardWin.createDrawingLayer(1);

// when a new game is selected, generate the score card image
gameList.on("gameselect", ev => {
    // Draw a score card, given the game title, a headline,
    // and the score text.  We'll invoke this when a newly
    // selected game's high scores are retrieved.
    function drawScoreCard(title, headline, scores)
    {
        // The color scheme, font, and vertical margin, in
        // pixels.  Change these to tweak the style as desired.
        let txtColor = 0xff000000, bgColor = 0xffffffff;
        let font = "Arial";
        let vertMargin = 16;

        // Drawing function.  We pass this to the drawing
        // layer's draw() method to do the drawing work.
        let yStart, yEnd;
        function drawFunc(dc)
        {
            // Fill the background.  If you want to use custom
            // graphics from a PNG or JPEG file instead for the
            // background fill, you can replace this with a call
            // to drawImage().
            let sz = dc.getSize();
            dc.fillRect(0, 0, sz.width, sz.height, bgColor);

            // Set the text clipping area to a very tall height
            // (effectively infinite).  This lets us measure the
            // actual height if the text is too tall vertically
            // for the current canvas.  The text renderer stops
            // bothering to keep track once the text goes past
            // the end of the clipping area, so we have to extend
            // the clipping area if we want an accurate height
            // overflow measurement.  We do clip to the actual
            // canvas width, though, because we want the text
            // to be centered horizontally in the canvas (so
            // the renderer has to know the true desired layout
            // width), and we also want the renderer to take
            // care of word-wrapping if any lines are too long,
            // which it can only do if it knows the width.
            dc.setTextArea(0, 0, sz.width, 8000);

            // Set the text origin - this is the initial "cursor"
            // position where we start drawing text.  The text
            // renderer advances this past each block of text,
            // so we only have to do this once at the start of
            // the text.  
            dc.setTextOrigin(0, yStart + vertMargin);

            // Center the text horizontally (0) and align at the
            // top vertically (-1).  Note that we *really* want
            // the text vertically centered, too, but we have to
            // do that ourselves by doing the two-pass height
            // calculation.  drawText() can only align a single
            // piece of text, which isn't helpful when we want
            // to align a mixture of styles, which we have to
            // draw separately.  Since we already know the
            // correct starting point for vertical centering,
            // we want drawText() draw exactly at the current
            // cursor vertically.
            dc.setTextAlign(0, -1);

            // Set the text color.  If you wanted to draw the
            // various sections in different colors, you could
            // add another setTextColor call just before drawing
            // each section's text.
            dc.setTextColor(txtColor);

            // draw the title in large text
            dc.setFont(font, 30, 700, false);
            dc.drawText(title + "\n \n");

            // draw the headline in a slightly smaller font
            dc.setFont(font, 24, 700, false);
            dc.drawText(headline + "\n \n");

            // add the score text, if available
            if (scores) {
                dc.setFont(font, 18, 700, false);
                dc.drawText(scores);
            }

            // add the customary disclaimer as a footer
            dc.setFont(font, 24, 700, false);
            dc.drawText("\nFOR AMUSEMENT ONLY\n");
            
            // Remember the vertical offset of the final text,
            // so that we can determine if we need to resize the
            // drawing surface to make more room.  
            yEnd = dc.getTextOrigin().y + vertMargin;
        }

        // We draw the card in two passes.  The first pass is
        // a dry run that lets us measure the actual height of
        // the text as laid out, so that we can (a) determine
        // how big the canvas needs to be to accommodate all
        // of the text, and (b) center the text vertically in
        // the canvas.  The only accurate way to determine the
        // text height with word-wrapping is to draw it.

        // First pass: draw the card into a small canvas, to
        // measure the height.  We make the canvas small on
        // this pass to minimize the memory footprint of the
        // internal bitmap, since we're just going to discard
        // it anyway.
        yStart = 0;
        scoreCardLayer.draw(drawFunc, 640, 16);

        // Now that we know the actual text height, figure the
        // size of the canvas.  Start with 640x480, and scale it
        // up if the text is too tall for that.
        let ht = 480, wid = 640;
        if (yEnd > ht) {
            wid *= yEnd/ht;
            ht = yEnd;
        }

        // figure the starting vertical position to center the
        // whole thing vertically, by halving the leftover height
        yStart = (ht - yEnd)/2;

        // Now we can finally do the REAL card drawing pass
        scoreCardLayer.draw(drawFunc, wid, ht);
    }

    // If there's a game, get its high score list and use it
    // to generate the score card.  If not, generate a default
    // placeholder card instead.
    if (ev.game) {
        // retrieve the high scores
        ev.game.getHighScores().then(
            scores => {
                // got 'em - draw the score card graphics
                drawScoreCard(ev.game.title.toUpperCase(),
                    "FREE PLAY - PRESS START", 
                    scores.join("\n"));
            },
            error => {
                // error - just draw a generic Free Play card
                drawScoreCard(ev.game.title.toUpperCase(),
                    "FREE PLAY - PRESS START");
            }
        );
    }
    else {
        // no game is selected; draw a generic placeholder
        drawScoreCard("PinballY", "Please select a game using the menus");
    }
});
</div>

<p>
   I'll suggest one simple embellishment.  The code above draws
   plain black text on a white background.  That's exactly the
   same style as the stock instruction cards and pricing cards
   on most real pinball machines, so it'll harmonize perfectly
   with your Instructions Card monitor for most games.  If you
   prefer some more color, you could easily throw in a
   call to <tt>dc.setTextColor()</tt> before each block of
   text.  For even more color, you could provide some background
   media for each card.  The still backglass image creates a
   fairly nice effect for many games, and they're practically
   no added work to use, since you probably already have
   them from screen captures or HyperPin media packs.  Here's
   how you could add an overlay effect that keeps the black-on-white
   look of the main text, but overlays it on top of a washed-out
   image of the backglass:
</p>
<ul>
   <li>In the custom window definition, add <tt>backgroundImageMediaType: "bg image"</tt>.
   The window will now automatically load the current game's backglass image into the background.

   <li>In the drawing code, change the background color to <tt>bgColor = 0xE8FFFFFF</tt>.
   That'll make the card image <i>slightly</i> transparent, which
   lets the backglass image show through just enough to be visible, without obscuring the text.

   <li>You can tweak the "alpha" opacity part (the E8 in the <tt>bgColor</tt> above) to
   adjust how strongly the backglass image shows through.  Use higher numbers to make
   it look more washed out, and use lower numbers to make the colors look more
   saturated.  If you want a very saturated look, you might find that it looks
   better to switch to white text on a black background, which you can do by
   changing the <tt>txtColor</tt> and <tt>bgColor</tt> variables in the drawing code.
</ul>
   

</body>
</html>
